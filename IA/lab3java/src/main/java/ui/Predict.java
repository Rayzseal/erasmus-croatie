package ui;

import java.util.ArrayList;
import java.util.Collections;

import struct.Dataset;
import struct.Label;
import struct.Value;
import tree.Tree;
import tree.Node;

/**
 * 
 * Class predict, used to train and predict. 
 * Will print the according results on the screen. 
 * @author chloe
 *
 */
public class Predict {

	private Dataset datasetTrain;
	private Dataset datasetTest;
	private Tree tree;
	private ArrayList<String> expected;
	private ArrayList<String> obtained;
	private double confMat[][];

	/**
	 * Constructor of the predict class. 
	 * Will use the id3 algorithm to learn data from the train dataset and will predict the according 
	 * results using the test file. 
	 * You can choose to limit the depth of the tree generated by id3 algorithm by setting the value of depth
	 * to the depth of the tree you want to use. 
	 * @param datasetTrain Training dataset.
	 * @param datasetTest Testing dataset. 
	 * @param depth Depth of the tree generated by id3 algorithm. 
	 */
	public Predict(Dataset datasetTrain, Dataset datasetTest, int depth) {
		this.datasetTrain = datasetTrain;
		this.datasetTest = datasetTest;
		this.expected = new ArrayList<String>();
		this.obtained = new ArrayList<String>();

		ID3 id3 = new ID3(depth);
		id3.id3(datasetTrain, datasetTrain, null, 0);
		this.tree = id3.getTree();
		this.tree.display();

		this.predict();
		this.display();
	}

	/**
	 * Predict method, will basically predict using the previously generated tree.
	 */
	public void predict() {
		
		// For every label in the test datatset
		for (int indexLab = 0; indexLab < this.getDatasetTest().getLabels().size(); indexLab++) {
			
			int indexNode = 0;
			
			Node node = null;
			boolean foundRoot = false;
			
			// This few lines are basically here to check if a value is contained (for this, 
			// the name of the value and the feature of the value need to be equal) in a certain label 
			while (indexNode < this.tree.getRoot().size() && !foundRoot) {
				int tmp = 0;
				boolean foundBis = false;
				while (tmp < this.getDatasetTest().getLabels().get(indexLab).getValues().size() && !foundBis) {
					if (this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getFeature().getName()
							.equals(this.tree.getRoot().get(indexNode).getValue().getFeature().getName())
							&& this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getName()
									.equals(this.tree.getRoot().get(indexNode).getValue().getName())) {
						node = this.tree.getRoot().get(indexNode);
						foundBis = true;
						foundRoot = true;
					} else {
						tmp++;
					}
				}
				if (!foundBis)
					indexNode++;
			}
			// Unseen feature at root level 
			if (node == null ) {
				this.obtained.add(ID3.argmaxLabel(datasetTrain).getName());
			} else {
				while (node.getLabel() == null) {
					// This few lines are basically here to check if a value is contained (for this, 
					// the name of the value and the feature of the value need to be equal) in a certain label 
					int i = 0;
					boolean found = false;
					while (i < node.getChildren().size() && !found) {
						int tmp = 0;
						boolean foundBis = false;
						while (tmp < this.getDatasetTest().getLabels().get(indexLab).getValues().size() && !foundBis) {
							if (this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getFeature().getName()
									.equals(node.getChildren().get(i).getValue().getFeature().getName())
									&& this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getName()
											.equals(node.getChildren().get(i).getValue().getName())) {
								foundBis = true;
							} else {
								tmp++;
							}
						}
						// A value has been found : now the current node is the child node
						// And we will repeat this step while there are child with corresponding values
						if (foundBis) {
							node = node.getChildren().get(i);
							found = true;
						}
						i++;
					}
					// Unseen feature --> we will create a new datasets using the values that we were able to find
					// Using this reconstructed dataset, we will get the label the most present in this small dataset
					// And it will the result of our prediction for this label
					if (!found) {
						Dataset datasetTmp = new Dataset(this.getDatasetTrain(), createDatasetForValues(node));
						this.obtained.add(ID3.argmaxLabel(datasetTmp).getName());
					}
				}

				// A result has been found
				if (node.getLabel() != null ) {
					// This few lines are basically here to check if a value is contained (for this, 
					// the name of the value and the feature of the value need to be equal) in a certain label 
					int tmp = 0;
					boolean foundBis = false;
					while (tmp < this.getDatasetTest().getLabels().get(indexLab).getValues().size() && !foundBis) {
						if (this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getFeature().getName()
								.equals(node.getValue().getFeature().getName())
								&& this.getDatasetTest().getLabels().get(indexLab).getValues().get(tmp).getName()
										.equals(node.getValue().getName())) {
							
							foundBis = true;
							
						} else {
							tmp++;
						}
					}
					// A value has been found
					if (foundBis) {
						this.getObtained().add(node.getLabel().getName());
					}
				}
			}
		}
	}


	/**
	 * Reconstruct the values that have been seen for a given node. 
	 * Will basically use the parent node to get all the visited values 
	 * and add those values to a list. 
	 * @param node Node to get the visited values from.
	 * @return The list of values visited by a node. 
	 */
	public ArrayList<Value> createDatasetForValues(Node node) {
		ArrayList<Value> tmp = new ArrayList<Value>();
		while (node.getParent() != null) {
			tmp.add(node.getValue());
			node = node.getParent();
		}
		return tmp;
	}

	/**
	 * Computes the accuracy. 
	 * @return The value of the accuracy (in the correct format)
	 */
	public String accuracy() {

		double correct = 0;
		double all = 0;
		double res = 0;

		// Get matrix
		this.confMat = matrix();

		// For all values of result matrix
		for (int i = 0; i < this.confMat.length; i++) {
			for (int y = 0; y < this.confMat[i].length; y++) {
				// Diagonal values
				if (i == y)
					correct += this.confMat[i][y];
				all += this.confMat[i][y];
			}
		}

		res = correct / all;
		
		return String.format("%.5f", res).replace(",", ".");
	}

	/**
	 * Creates the confusion matrix. 
	 * @return the confusion matrix. 
	 */
	public double[][] matrix() {
		ArrayList<Label> possibleLabels = this.getDatasetTest().getPossibleLabels();
		ArrayList<String> possibleStringForLabels = new ArrayList<String>();

		// ArrayList of strings of possible labels
		for (Label l : possibleLabels)
			possibleStringForLabels.add(l.getName());

		// Size of the list, used to initialize our table
		int size = possibleLabels.size();
		double matrix[][] = new double[size][size];

		Collections.sort(possibleStringForLabels);

		// Set the results into getExpected
		for (Label l : this.getDatasetTest().getLabels())
			this.getExpected().add(l.getName());

		// Set the results into the corresponding colums / lines
		for (int y = 0; y < this.getObtained().size(); y++) {
			int index1 = possibleStringForLabels.indexOf(this.getExpected().get(y));
			int index2 = possibleStringForLabels.indexOf(this.getObtained().get(y));
			// System.out.println("index1 "+index1+" index2 "+index2);
			matrix[index1][index2]++;
		}

		// Return the matrix of results
		return matrix;
	}

	/**
	 * Print the results for 2 given datasets (training and testing). 
	 * Display : the id3 training tree, the predictions obtained, the accuracy, the confusion matrix. 
	 */
	public void display() {
		System.out.print("[PREDICTIONS]: ");
		for (int i = 0; i < this.getObtained().size(); i++)
			System.out.print(this.getObtained().get(i) + " ");

		System.out.println("\n[ACCURACY]: " + this.accuracy());
		System.out.println("[CONFUSION_MATRIX]:");
		for (int i = 0; i < confMat.length; i++)
			for (int y = 0; y < confMat[i].length; y++)
				if (y == confMat[i].length - 1)
					System.out.print((int) confMat[i][y] + "\n");
				else
					System.out.print((int) confMat[i][y] + " ");
	}

	/**
	 * @return the datasetTrain
	 */
	public Dataset getDatasetTrain() {
		return datasetTrain;
	}

	/**
	 * @return the datasetTest
	 */
	public Dataset getDatasetTest() {
		return datasetTest;
	}

	/**
	 * @return the tree
	 */
	public Tree getTree() {
		return tree;
	}

	/**
	 * @param datasetTrain the datasetTrain to set
	 */
	public void setDatasetTrain(Dataset datasetTrain) {
		this.datasetTrain = datasetTrain;
	}

	/**
	 * @param datasetTest the datasetTest to set
	 */
	public void setDatasetTest(Dataset datasetTest) {
		this.datasetTest = datasetTest;
	}

	/**
	 * @return the expected
	 */
	public ArrayList<String> getExpected() {
		return expected;
	}

	/**
	 * @return the obtained
	 */
	public ArrayList<String> getObtained() {
		return obtained;
	}

	/**
	 * @param expected the expected to set
	 */
	public void setExpected(ArrayList<String> expected) {
		this.expected = expected;
	}

	/**
	 * @param obtained the obtained to set
	 */
	public void setObtained(ArrayList<String> obtained) {
		this.obtained = obtained;
	}

	/**
	 * @param tree the tree to set
	 */
	public void setTree(Tree tree) {
		this.tree = tree;
	}
}
